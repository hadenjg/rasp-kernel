Copying last entry from notes and now keeping track here so I can develop away from home as well:

02/19/24 ----------------------------------------------------------------------------------------------------------------------------------
Got the device driver working and the device reads the sensor information correctly!  So the tutorial worked.
now I am going to write a device driver for the CAP1188 using i2c then spi

Then I am going to do the block device flash/eeprom thing i have.

Then once I have written all these device drivers.  I will implement them in a yocto build somehow or atleast learn how to do that.

because I don't want to do the yocto stuff now and wipe the harddrive for the raspberry pi. Cause then I'll jsut have to reflash it.

Right now I need to be able to transfer what I learned from the last device driver (the basic ideas)
then i need to implement communicating over i2c instead.. (and then spi)

https://embetronicx.com/tutorials/linux/device-drivers/i2c-linux-device-driver-using-raspberry-pi/

https://learn.adafruit.com/adafruit-cap1188-breakout/pinouts

and then instead of make files figure out how to use cmake files
https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ProductDocuments/DataSheets/00001620C.pdf

Fuck the other things I posted.  It seems that the i2c device driver is already created (duh) and we just have to read/write to it like its a file....
 which makes me wonder what writing this device driver must be like?  
 although that shit is probably provided to us from manufactureres 
 liek for the ccu like shawn said

 https://elinux.org/Interfacing_with_I2C_Devices
 https://docs.kernel.org/i2c/writing-clients.html
https://learn.sparkfun.com/tutorials/i2c/all
https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ProductDocuments/DataSheets/00001620C.pdf


https://elinux.org/Interfacing_with_I2C_Devices


04/05/24-------------------------------------------------------------------------------------------------

==============================
Useful links:
==============================
https://embetronicx.com/linux-device-driver-tutorials/
https://embetronicx.com/tutorials/linux/device-drivers/i2c-linux-device-driver-using-raspberry-pi/#How_I2C_bus_driver_works

https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ProductDocuments/DataSheets/00001620C.pdf

https://pinout.xyz/
==============================

OK SINCE I DON"T REMEMBER ANYTHJING

start simple and just create the hello world version of this shit.  Then work on actually implementing the device....

To keep these notes updated... will have to upload them to github or something...


cool atleast we got make to work....


cleaned up repsoitory and rreacquainted myself with all this stuff.  Also got vs code to actually link to the linux kernel libraries

04/07/24-------------------------------------------------------------------------------------------------

After I get this working, get a yocto build for it and put that on another sd card??

04/08/24-------------------------------------------------------------------------------------------------

==============================
Useful links:
==============================
https://embetronicx.com/linux-device-driver-tutorials/
https://embetronicx.com/tutorials/linux/device-drivers/i2c-linux-device-driver-using-raspberry-pi/#How_I2C_bus_driver_works
kernel.org/doc/html/v4.14/driver-api/i2c.html

https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ProductDocuments/DataSheets/00001620C.pdf

github.com/torvalds/linux/blob/master/include/linux/i2c.h

upto date somewhat:
kernel.org/doc/html/latest/i2c/writing-clients.html

https://pinout.xyz/
==============================

finished following the guide.  Now going to try and understand what is actually going on..  (and i didn't implement the actual device.  I attempted to build as is, and it died as expected.

instead of probe you should use probe_new (probe is soon to be deprecated

"For automatic device detection, both detect and address_list must be defined. class should also be set"


///////////04/09/24

the guide has some outdated i2c commands in there.  The most uptodate stuff is in:
github.com/torvalds/linux/blob/master/include/linux/i2c.h

had to update i2c_new_device to i2c_new_client_device

also have to update the i2c_driver so that remove returns a void * to something instead of an int

today I was able to get the module to build with no errors.  It is still a skeleton with no functionality, but atleast it builds

///////////04/10/24

Ok so yesterday I got the skeleton together, today I will try to get some sort of info or atleast take the steps to get some sort of info from the chip onto the pi...

walking through init

after i2c_add_driver is called "all the i2c devices will be traversed.  Once matched, the probe function of the driver will be executed"

since this device can set leds as well as read info.  I guess the best thing to
do just to verify that I am communicating at all is to write a value to just turn the ledon and then off.  (upon inserting and removing the module)  That would be a good basic thing to do

So based on the CAP1188 pdf I should 

write to 00 for the main power control


reading through the data sheet....  Trying to figure out how to get an led to turn on

//////////04/15/2024

github.com/torvalds/linux/blob/master/drivers/input/keyboard/cap11xx.c

looks like its actaully already in the linux kernel lol
but i am having a hard time understanding exactly what they are doing since it is implementing not only CAP1188 but all CAP11xx devices.

module_i2c_driver() can replace module_init and module_exit

but I'll leave it in there for now:

To do:
1.) turn an led on and off
2.) eventually replace init and exit with module_i2c_driver()


ok led stuff:

5.31 led behavior registers

5.28 Led output control register (this may be how to do it (by default the leds are not
connected to the sensors))


04/16/24-------------------------------------------------------------------------------------------------

==============================
Useful links:
==============================
https://embetronicx.com/linux-device-driver-tutorials/
https://embetronicx.com/tutorials/linux/device-drivers/i2c-linux-device-driver-using-raspberry-pi/#How_I2C_bus_driver_works
kernel.org/doc/html/v4.14/driver-api/i2c.html

https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ProductDocuments/DataSheets/00001620C.pdf

github.com/torvalds/linux/blob/master/include/linux/i2c.h

upto date somewhat:
kernel.org/doc/html/latest/i2c/writing-clients.html

//seemingly correct way to go about this:
github.com/torvalds/linux/blob/master/drivers/input/keyboard/cap11xx.c

https://pinout.xyz/
==============================
TODO:
=============================
General Knowledge/Problems
============================
1.) Turn an led on XXXXXXXXX
2.) eventually replace __init and -_exit with module_i2c_driver()
3.) replace the manual operation of wrting with i2c to that regmap thing that was being done 
in the kernel code for cap11xx 
4.) investigate message "loading out-of-tree module taints kernel"
5.) look into difference between smbus and i2c

Then:
6.) Properly Initialize the device (have leds light up when sensors are touched and look at what other regs do)
7.) recieve the sensor information from device
8.) write user app that prints the sensor info to the screen
9.) upon shutdown have the device clear the registers
============================

Success!!!  
I was able to turn all the leds on the cap1188 device!!!  

 the tutorial I am following and what is actually written in the kernel are two very different beasts
the one in the kernel of course is looking for many different devices....

how to tell what is best practice???

Need to look into dbus message "loading out-of-tree module taints kernel."

Ok there does not seem to be any real place anywhere that has a definitive answer for any of this lol

Just have to keep cobbling and see what works and doesn't work lol.  

The skeleton is atleast the same.  Its just the interactions with the kernel that can change or have 
more streamlined ways of doing things....

ok now that I got it to atleast write to the led I can do some other stuff......

1.) Initialize the device
2.) recieve the sensor information from device
3.) write user app that prints the sensor info to the screen
4.) upon shutdown have the device clear the registers

1.) write a new module for spi version of doing it


04/17/24-------------------------------------------------------------------------------------------------

==============================
Useful links:
==============================
https://embetronicx.com/linux-device-driver-tutorials/
https://embetronicx.com/tutorials/linux/device-drivers/i2c-linux-device-driver-using-raspberry-pi/#How_I2C_bus_driver_works
kernel.org/doc/html/v4.14/driver-api/i2c.html

https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ProductDocuments/DataSheets/00001620C.pdf

github.com/torvalds/linux/blob/master/include/linux/i2c.h

upto date somewhat:
kernel.org/doc/html/latest/i2c/writing-clients.html

//seemingly correct way to go about this:
github.com/torvalds/linux/blob/master/drivers/input/keyboard/cap11xx.c

https://pinout.xyz/
==============================
TODO:
=============================
General Knowledge/Problems
============================
2.) eventually replace __init and -_exit with module_i2c_driver()
3.) replace the manual operation of wrting with i2c to that regmap thing that was being done 
in the kernel code for cap11xx 
4.) investigate message "loading out-of-tree module taints kernel"

Then:
6.) Properly Initialize the device (have leds light up when sensors are touched and look at what other regs do)
7.) recieve the sensor information from device
8.) write user app that prints the sensor info to the screen
9.) upon shutdown have the device clear the registers

Extra:
5.) look into difference between smbus and i2c
10.)Try to use the inbuild kernel module for this chip and see what happens
11.) Create a developers blog about the journey so far?
============================

trying to figure out module_i2c_driver thing to get rid of boiler plate stuff.... it seems to insert the module, but my probe is not being called.....

What can I do to fix this??
